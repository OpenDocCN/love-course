# 男哥内核3.0初级班：内部课：17.实战案例讲解 🚀

在本节课中，我们将通过一个具体的实战案例，来综合运用之前所学的内核编程知识。我们将从问题定义开始，逐步分析、设计并实现一个简单的内核模块，以加深对核心概念的理解。

---

## 案例背景与目标

上一节我们介绍了内核模块的基本结构，本节中我们来看看如何将这些知识应用于解决一个实际问题。

我们的目标是编写一个内核模块，用于监控系统中新进程的创建。该模块需要在内核中注册一个回调函数，当任何进程被创建（`fork`系统调用成功返回）时，该函数会被触发，并打印出新进程的进程ID（PID）和其父进程的进程ID（PPID）。

---

## 核心概念与实现方案

要实现进程创建监控，我们需要理解Linux内核提供的进程事件通知机制。Linux内核有一个名为`task_struct`的数据结构，它代表一个进程或线程。为了监控进程创建事件，我们可以使用内核提供的“进程事件连接器”（`process events connector`）机制，或者更简单地，使用`kprobes`来钩住`do_fork`函数（或其变体，如`_do_fork`、`kernel_clone`，具体取决于内核版本）。

考虑到简单性和教学目的，本案例将使用`kprobes`技术。`kprobe`允许我们在内核函数的入口或出口处动态插入探测点，从而执行我们自定义的处理程序。

以下是实现此功能的核心步骤概述：

1.  **定义处理函数**：创建一个函数，当`do_fork`被调用时执行，用于提取并打印PID和PPID。
2.  **注册kprobe**：初始化一个`kprobe`结构体，将其指向`do_fork`函数，并关联我们的处理函数。
3.  **模块初始化与退出**：在模块加载时注册kprobe，在模块卸载时注销kprobe。

---

## 代码实现详解

以下是具体的代码实现，我们将逐部分进行解释。

### 1. 模块头文件与许可证声明

任何内核模块都必须包含必要的头文件并声明许可证。

```c
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/kprobes.h>
#include <linux/sched/task.h> // 用于访问进程任务结构

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Your Name");
MODULE_DESCRIPTION("A simple module to monitor process creation.");
```

### 2. 定义kprobe与处理函数

首先，我们定义一个`kprobe`结构体实例。然后，实现我们的前置处理函数（`pre_handler`），它将在`do_fork`函数执行前被调用。

```c
static struct kprobe kp;

// kprobe的前置处理函数
static int handler_pre(struct kprobe *p, struct pt_regs *regs)
{
    // 在较新内核中，do_fork的参数可能通过寄存器或堆栈传递。
    // 这是一个简化示例。实际应用中，需要根据内核版本和架构分析参数位置。
    // 这里我们假设能通过current宏获取当前上下文（即正在创建子进程的父进程）。
    struct task_struct *parent = current;
    pid_t parent_pid = parent->pid;

    // 注意：此时子进程尚未创建完成，我们无法直接获取其pid。
    // 更完善的监控通常需要在后置处理函数中操作，或使用其他跟踪机制（如tracepoint）。
    // 此处为教学演示，我们仅打印父进程PID。
    printk(KERN_INFO "Process Creation Monitor: Parent PID %d is forking.\n", parent_pid);
    return 0;
}
```

**重要说明**：由于`do_fork`函数的参数传递和调用约定复杂且随内核版本变化，直接在上面函数中获取子进程PID是困难的。生产环境应使用`tracepoint`（如`sched_process_fork`）或`ftrace`。本案例为保持简洁，聚焦于kprobe的基本用法。

### 3. 模块初始化函数

在模块初始化函数中，我们设置kprobe并注册它。

```c
static int __init monitor_init(void)
{
    int ret;

    // 指定要探测的函数名
    kp.symbol_name = "do_fork";
    // 关联我们的前置处理函数
    kp.pre_handler = handler_pre;

    // 尝试注册kprobe
    ret = register_kprobe(&kp);
    if (ret < 0) {
        printk(KERN_ERR "Failed to register kprobe, error %d\n", ret);
        return ret;
    }

    printk(KERN_INFO "Process creation monitor module loaded. Probing %s.\n", kp.symbol_name);
    return 0;
}
```

### 4. 模块退出函数

在模块退出时，必须注销kprobe以清理资源。

```c
static void __exit monitor_exit(void)
{
    unregister_kprobe(&kp);
    printk(KERN_INFO "Process creation monitor module unloaded.\n");
}
```

### 5. 指定模块入口与出口

最后，使用宏来指定模块的初始化函数和退出函数。

```c
module_init(monitor_init);
module_exit(monitor_exit);
```

---

## 编译与测试步骤

编写完代码后（假设文件名为`monitor_process.c`），我们需要编译它并将其加载到内核中。

以下是操作步骤：

1.  **编写Makefile**：在与`monitor_process.c`相同的目录下创建`Makefile`。
    ```makefile
    obj-m += monitor_process.o
    KDIR := /lib/modules/$(shell uname -r)/build
    PWD := $(shell pwd)

    all:
        $(MAKE) -C $(KDIR) M=$(PWD) modules

    clean:
        $(MAKE) -C $(KDIR) M=$(PWD) clean
    ```

2.  **编译模块**：在终端执行`make`命令。成功后会生成`monitor_process.ko`文件。

3.  **加载模块**：使用`sudo insmod monitor_process.ko`命令加载模块。

4.  **查看日志**：使用`dmesg | tail`或`sudo journalctl -k --since “1 minute ago”`命令查看内核日志，应该能看到类似“Process Creation Monitor: Parent PID XXXX is forking.”的信息。

5.  **触发测试**：在系统中打开新的终端或运行任何命令（如`ls`），创建新进程，观察内核日志的输出。

6.  **卸载模块**：测试完成后，使用`sudo rmmod monitor_process`命令卸载模块。

---

## 注意事项与扩展思考

在实现和使用此类内核模块时，有几个关键点需要注意：

*   **内核版本兼容性**：`do_fork`函数名和签名可能在不同内核版本中发生变化。在实际开发中，需要使用宏或版本检测来保证兼容性。
*   **生产环境适用性**：`kprobes`更适合调试和动态分析。对于稳定的生产级监控，建议使用`tracepoints`或`eBPF`技术，它们更安全、性能更好。
*   **错误处理**：本示例代码做了简化。健壮的模块应有更完善的错误处理和资源管理。
*   **安全性**：内核模块运行在最高权限级别，错误的代码可能导致系统崩溃（内核恐慌）。请在测试环境中操作。

你可以尝试扩展这个案例：
*   尝试修改代码，监控进程退出事件（可以探测`do_exit`函数）。
*   研究并使用`sched_process_fork`这个tracepoint来重写本案例，并尝试获取子进程的PID。

---

## 总结

本节课中我们一起学习了一个内核编程的实战案例。我们从监控进程创建的需求出发，分析了使用`kprobe`技术的解决方案，并逐步实现了一个能够打印进程创建信息的内核模块。通过这个案例，我们综合运用了模块编写、函数钩子、内核日志打印等知识，并了解了从编码、编译到加载测试的完整流程。希望这个案例能帮助你更好地理解如何将内核编程知识应用于解决实际问题。